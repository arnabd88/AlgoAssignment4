\documentclass{article}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\usepackage{float}
\usepackage{longtable}
\setlength{\parindent}{0pt}
\setlength{\parskip}{5pt plus 1pt}
\setlength{\headheight}{13.6pt}
\newcommand\question[2]{\vspace{.25in}\hrule\textbf{#1: #2}\hrule\vspace{.10in}}
\renewcommand\part[1]{\vspace{.10in}\textbf{(#1)}}
\newcommand\algo{\vspace{.10in}\textbf{Algorithm: }}
\newcommand\correctness{\vspace{.10in}\textbf{Correctness: }}
\newcommand\runtime{\vspace{.10in}\textbf{Running time: }}
\newcommand\pseudoCode{\vspace{.10in}\textbf{PseudoCode: }}
\newcommand*{\perm}[2]{{}^{#1}\!P_{#2}}
\newcommand*{\comb}[2]{{}^{#1}\!C_{#2}}
%\pagestyle{fancyplain}
%\lhead{\textbf{\NAME\ (\UID)}}
%\chead{\textbf{Hw\HWNUM}}
%\rhead{CS 6350, \today}
\title{CS6150 - Homework/Assignment-4}
\author{Arnab Das(u1014840)}
\usepackage[utf8]{inputenc}
\begin{document}
  \pagenumbering{gobble}
  \maketitle
  \newpage
  \pagenumbering{arabic}
  \newcommand\NAME{ARNAB DAS}
  \newcommand\UID{uxxxxxxx}
  \newcommand\HWNUM{4}
  
  %%---------- Question-1 -----------------
  \question{1}{Minimum Spanning Tree}
  \part{a} Let G be weighted directed graph with all edge weights being distinct. \textbf {Prove:} G has an unique spanning tree: \newline
  \textbf {Proof:} Consider G has two spanning trees, $T_{1}$ and $T_{2}$. Let $e_{1}$ be the edge with the minimum weight in the graph that is contained in $T_{1}$ and not in $T_{2}$. Then $T_{2} \cup e_{1}$ results in a cycle, say C. Then  one of the other edges of C, say $e_{2}$ is not in $T_{1}$, else $T_{1}$ would have had a cycle.  Then, if we replace $e_{2}$ by $e_{1}$ in $T_{2}$, that would result in a spanning tree with a smaller weight than $T_{2}$. Then $T_{2}$ is not a spanning tree. Hence $T_{1}$ is a unique spanning tree. (Proved) \newline

  \part{b} Even if the weights of the graph are not distinct, it is still possible to get a unique spanning tree. We describe below an algorithm , that is a slight modification of the Kruskal algorithm. Given a weighted graph $G=(V,E,W)$, where V denotes the set of vertices, E denotes the set of edges and W denotes the edge weights. Consider initially a setting of all the nodes without any of the edges, each is a separate tree. Then we gradually build up the minimum spanning tree(mst) by union of these disjoint trees. We always start with the edge of minimal weight at every step, and if the end points of that edge lies in two different trees, then that edge acts as the union of these two trees resulting in a bigger tree. If , the end-points of the edge lie in the same tree, that edge, if added, will contribute to a cycle in that tree. In Kruskal's we ignore this edge. However, we can use this edge to detect non-uniqueness. Once a cycle is detected, then in that tree, we look for another edge that has the same weight as out current edge. If there exists another such an edge, that leads to the conclusion that it is not unique, since the other edge could have been replaced with the current edge, still yielding the minimum spanning tree.   \newline
  \pseudoCode \newline
  \hspace*{0.0cm} \textbf {KRUSKAL(G(V,E,W))}: \newline
  \hspace*{0.5cm} //  Graph represented as triples(u,v,w), where u,v are the edge end-points and w the edge weight w(u,v). \newline
  \hspace*{0.5cm} \textbf {H=BuildHeap}(G(V,E,W)) \newline
  \hspace*{0.5cm} \textbf {foreach} $u \in V$ \newline
  \hspace*{1cm}     Make-Set(u) \newline
  \hspace*{0.5cm} T = $NULL$ // This corresponds to the spanning set. \newline
  \hspace*{0.5cm} \textbf {while} ($|T|$ = n-1) // if still spanning \newline
  \hspace*{1cm}		(u,v,w) = ExtractMin(H) \newline
  \hspace*{1cm}		Uset = Find(u) \newline
  \hspace*{1cm}		Vset = Find(v) \newline
  \hspace*{1cm}		\textbf {if} (Uset $\neq$ Vset) \newline
  \hspace*{1.5cm}		$T = T \cup {(u,v)}$ \newline
  \hspace*{1.5cm}		\textbf {Merge}(Uset, Vset) \newline
  \hspace*{1cm}		\textbf {else} // indicates part of same tree, hence contributes to a cycle \newline
  \hspace*{1.5cm}		bool x = search(w, Uset) // search for the same weight value in the Uset \newline
  \hspace*{1.5cm}		\textbf {if} (x=true) \textbf {return} $MST\_NOT\_UNIQUE$ \newline
  \hspace*{0.5cm} return $MST\_UNIQUE$ \newline

  \correctness 
    The correctness is same as Kruskal's algorithm. Consider that Kruskal's algorithm gives a minimum spanning tree, M=(V,F), where F is the set of the edges in the MST. Then, if there exists an edge, e, in E-F, such that adding e to the M yields a cycle, C, and if weight(e)=m is the lowest edge weight in $F \cap C$, then we can swap that edge of $F \cap C$ with e, yoielding another spanning tree. This is exactly the part executed by 'search' and hence guaranteed correctness. We searches for same weight edges in the Uset corresponding to the edge of the current edge when a cycle is detected, and if found we say the MST is not unique, else the MST is unique. Thus, we have modified the Kruskal's algorithm to dynamically find the MST uniqueness. \newline

  \runtime
  We use the heap structure to store the data, and use the weight of the edges as the keys for creating the heap. The heap creation takes time $O(|E|)$. The Kruskal's algorithm takes $(|E|+|V|)log|V|)$. Additionally , for the search operation, we need to perform a breadth first search on the subtree where a cycle is found. Breadth first search is $O(|E|+|V|)$, and atmost we do that for $(V-1)$ times. So the overall bound comes to be polynomial. 



    \question{2}{Max Flow Basics \dots}
    \part{a} Given G is a directed graph with edges having \textbf {integer} capacity. \newline
    \textbf {To Prove:} For any s,t there exists a maximum flow between s,t in which every edge has an integeral flow on it. \newline
    \textbf {Proof:} The proof can be broken down into two parts. First we show that at every iteration iteration , the flow value on every edge f(u,v) and hence the flow of the augmenting paths are integers, and second that the iteration terminates. \newline
    \textbf {First:} Goal: At every intermediate step of the Ford-Fulkerson algorithm, the values f(u,v) and the residual capacities are integers. \newline
    \hspace*{0.5cm} At iteration 0, this is true by construction of the graph that the given flow capacities of every edge are integer values and the intialized flow capacities are zero. Now, suppose it is true after 'j' iterations. Then, if $G_f$ is the residual graph after the j'th iteration, the bottleneck evaluated in the (j+1) iteration will also be integer since all the residual capacities in $G_{f}$ and the flow values are integers. Now, since the capacities and the residual capacities are integers, then the flow on every edge must also be an integer as for a forward edge e,Residual Capacity = $c_e$ - f(e), and for a backward edge of e, Residual Capacity = f(e), where $c_e$ is the capacity of the edge e and f(e) is the flow value of edge e in j'th iteration. Then, in the (j+1) iteration, in the new flow over an augmenting path, we either increase f(e) for forward edges by the bottleneck amount which is an integer addition resulting in an integer, and decrease f(e) for backedges by the bottleneck amount which is an integer subtraction resulting in an integer. Thus the new flow and all the flow values on the edges will have integer values in the (j+1) iteration. This also leads to the fact, that the residual capacities we evaluate to build the residual graph will also be integer values since they are evaluated as the difference of the current capacities and the flow values which we proved to be integers. Hence, by induction, at every intermediate step, the flow values and the residual capacities are integers. \newline
    \textbf {Second:} Goal: The algorithm terminates. \newline
    Since, the flow value at every step is increased by the bottleneck amount, which is a positive integer quantity, and it cannot go beyond the out flow from the source, this leads to the fact that the while loop is guaranteed to terminate in atmost C steps, where C is the total outflow from the source. \newline
    Combining the \textbf {first} and \textbf {second} proofs, we can say, that the step at which it terminates, the result would have yielded an integer maximum flow and the flows on every edge will have integer values. \newline

    \part{b} 
    \textbf{Case-1: Increase Capacity of an edge by 1} \newline    
    \algo As input, we are given the maximum feasible flow f in G, v(f) the value of f,an edge 'e' whose capacity is to be increased by 1, and we try to find a single augmenting path in $G^\prime$ which contains the edge 'e' whose capacity is increased by 1. We increase the capacity of the edge 'e' in the residual graph and find an augmenting path in the residual graph. If an augmenting path is found, it will have a bottleneck of '1' due to this increased capacity of 'e' and hence the flow value inctreases by 1. If an augmenting path is not found, then the flow value remains the same. \newline

    \correctness  Since, we have already reached the Maximum flow in G, thus there exists a s-t cut(A,B), such that all the paths crossing the cut are saturated and cannot carry any flow. Note that the maximum flow in $G^\prime$ is atleast v(f), since f is still a valid flow of the network as we haven't decreased the value of any capacity. All the edges across the cut have the same capacity in $G^\prime$ as in G with only exception of 'e'(if and only if e crosses the cut). In that case 'e' can provide a unit path across (A,B) and the flow can increase atmost by 1, else the flow remains the same. This guarantees the correctness of the algorithm. \newline

    \runtime We only need to find an augmenting path in the residual graph, which is $O(m+n)$, where m is the number of edges and n is the number of nodes in the network. This is significantly smaller than restarting the maximum flow evaluation from scratch. \newline


    \textbf {Case-2: Decrease Capacity of an edge by 1} \newline    
    \algo As input, we are given the maximum feasible flow f in G, v(f) the value of f, an edge 'e' whose capacity is to be decreased by 1. If the current capacity of 'e' is strictly greater than its flow value, return the current maxflow. Else,in the residual graph, we decrease the capacity of 'e' by 1 and increase the capacity of the backedge of 'e' by 1. Then attempt to find an augmenting path from sink(t) to the source(s). If an augmenting path is found, return 1 unit of flow from sink to source to balance the reduction in capacity. Next, run the augmenting path subroutine again from source to sink, to find a new augmentng path and recompute the flow. This new flow value is the maximum flow with the the capacity of 'e' reduced. \newline

    \correctness If the edge 'e' had not reached maximum capacity, that is, its capacity value was still greater than its flow value when the termination happended, then by decreasing its capacity it might atmost reach its full capacity in which case the current flow still remains valid. So, in that case we can say the maxflow in the modified capacity is still the same v(f). However, if the flow value of 'e' had reached its maximum capacity, then if we reduce its capacity, it means that we have transferred one additional unit from the source to the sink with respect to the new graph of modified capacities. Hence, somehow we need to take out this 1 unit of flow from the sink to the source to balance out and then recompute. Let e=(u,v) and source(s) and sink(t). Note that, since the edge 'e' had reached its capacity(assuming positive, else there would be no meaning of reducing it), that flow must have travelled through from v to t through some path, and hence there might be backedges that can provide a path from t to v that can flow atleast 1 unit. Similarly, since there was a non zero flow across 'e', that flow must have reached 'e' through some path from s to u. Then, there will be some backedges connecting from u to s that can atleast carry one unit of flow. If we can find such augmenting paths from t to v and from u to s, then we can tranfer this one unit of flow on 'e' back using the path t-v-u-s. The unit flow we aim to return can be modeled as an additional unit on the backedge of e, that (v,u). Finding the augmenting path from t to s, exactly serves this purpose. Once , we do this and return the flow back, we have established the network to a situation where the capacity of 'e' is reduced by 1, and the flow would have been v(f)-1. Now we try finding a forward augmenting path from s to t, and if found, that will increase the flow by atmost 1, or will remain the same(since flow never decreases over iterations and cannot exceed v(f), as v(f) was the max flow of a graph with highre capacity). Hence, the max-flow of this graph will be either v(f) or v(f)-1. This, guarantees the correctness of our algorithm. 
   

   \part{c} We use the following proposition to complete the final proof: \newline
   \textbf {Proposition} Let D be a directed graph such that every node v in D has indegree equal to its outdegree. Then there exists cycles $C_1, C_2, \dots, C_k$ so that every edge appears in exactly one of the cycles. \newline
   \textbf {Proof of the proposition:} First choose a maximal list of the cycles, $C_1,C_2,\dots,C_k$ so that every edge appears in atmost one. Suppose(\textbf {for contradiction}) that there is an edge not included in any cycle $C_i$ and let H be the component $D - \cup_{i=1}^kE(C_i)$ which contains an edge. Now, every vertex $v \in V(H)$, where V(H) is the vertex set of H, satisfies indegree(v)=outdegree(v)$\neq 0$. Then for n nodes, the degree sum is more than n, which will result in a cycle $C \subseteq H$. But then C may be appended to the List of cycles. This contradiction completes the proof. \newline
   \textbf {Proof Goal: } For any two vertices s,t and an integer $k \geq 1$ in directed graph G of edge capacities 1, there exists k edge disjoint paths from s to t, iff there exists k edge disjoint paths from t to s. \newline
   \textbf {Proof} Since, there exists cycles that covers every edge as per the proposition, the cycle $C_i$ covering the edges in the i'th edge disjoint path from s to t will require a path $i^\prime$ from t to s to complete the cycle. Since, the k paths are edge disjoint, they do not share any edge and hence they cannot be mutually part of the same cycle. Which means for the k edge disjoint paths from s to t , there exists atleast k cycles, and each of these k edge disjoint paths from s to t, covers their corresponding cycles from s to t. Then to complete the cycle, each of them will have a remaining path from t to s, and these paths will also be edge disjoint since the cycles cannot intersect else same edge will get covered in two cycles. Hence, in the reverse path from t to s, there also must exist k-edge disjoint paths if there needs to exists k edge disjoint paths from s to t.(Proved). \newline


   \question{3}{More Reductions to Flows \dots}
   \algo Consider the n departments set be labeled as $D={D_1, D_2, \dots, D_n}$ and the set of faculties be labeled as $F = {F_1, F_2, \dots , F_m}$. Also, suppose that there are 'r' ranks of professors. We can set up the problem as a maximum matching problem as shown in the figure below: \newline
  \begin{figure}[H]
   \centering
  \includegraphics[width=14cm, height=14cm]{Prob3a}
  \caption{Max Matching for committee formation}
  \end{figure}
  We set up a graph from set D to set F, and every edge from $d_i \in D$ to $f_j \in F$ indicates that faculty $F_j$ has appointment with department $D_i$. The weights of these edges are set to 1. The sets of $M={M_1, M_2, \dots , M_r}$ indicates the set of ranks. Thus an edge from $F_i$ to $M_j$ indicates that the faculty $F_i$ belongs to rank $M_j$. The outflow edges from the rank nodes to the sink(t) are given weights of $\dfrac{n}{r}$, such that every rank has equal representation to the final committee. The inflow edges from to the $D_i$ from the source is set to 1, such that the max outflow is n and every department is allowed to pick one faculty. Now we run ford-fulkerson algorithm and if the maximum flow of this network is equal to the max possible outflow from the source,that is n, , then we have a maximum matching solution. Then, we say that a committee can be formed with equal representation from all professors, and one professor for each different, and \textbf {return} the set of faculties for whom the flow value to their corresponding rank, that is, $F_i -> mj$ is 1.  If the max flow is not n, the return that such a committee cannot be formed. \newline

  \correctness The only way we can get a max flow of n, is if the flow from each rank is equal to $\dfrac{n}{r}$, since the capacities of these edges is limited to n/r . Each rank can contribute n/r if and only if, it gets contributions from (n/r) distinct faculties since the edge capacities between faculties to ranks is 1 and no faculty can have edge to multiple ranks. This leads to the fact that n distinct faculties are contributing to the entire rank set. Since, the edge weights from departments to faculties is also 1, the maximum matching solution ensures that one department gets flow 1 with exactly 1 faculty and no two departments gets match with the same faculty. Since, we have n faculties with flow 1 to the rank set, hence each of the n department must have an edge 1 faculty to conserve the flow. Thus, overall we ensure that each department has 1 representative faculty with no overlap across departments and that each rank of faculties have equal distribution in the final committee, if we get the max matching solution. This ensures correctness of our algorithm. \newline

  \runtime  To set-up the graph, we have to setup at maximum E=(n + mn + m + n) edges, hence this setup will be bounded in O(mn). The outflow from the source is n, so the Ford-Fulkersion is bounded by $O(n \times E)$ = $O(n(2n+mn+n))$ = $O(mn^2)$. 


  \question{3}{b}
   
 \end{document}

